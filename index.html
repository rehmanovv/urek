<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>üíú</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; height: 100%; background: black;
      display: flex; flex-direction: column;
      align-items: center;
      user-select: none;
    }
    #colorSliderContainer {
      width: 300px;
      height: 30px;
      margin: 10px;
      position: relative;
      cursor: pointer;
      background: linear-gradient(to right, 
        red, orange, yellow, green, cyan, blue, violet, magenta, red);
      border-radius: 5px;
      z-index: 10;
    }
    #sliderThumb {
      width: 12px;
      height: 30px;
      background: white;
      border-radius: 3px;
      position: absolute;
      top: 0;
      left: 0;
      transform: translateX(-50%);
      pointer-events: none;
    }
    #container {
      flex: 1;
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: black;
      position: absolute;
      top: 0; left: 0;
    }
  </style>
</head>
<body>
  <div id="colorSliderContainer" title="R…ôngi se√ß">
    <div id="sliderThumb"></div>
  </div>
  <div id="container">
    <canvas id="heart"></canvas>
  </div>
  <script>
    const slider = document.getElementById("colorSliderContainer");
    const thumb = document.getElementById("sliderThumb");

    let canvas = document.getElementById('heart');
    let ctx = canvas.getContext('2d');
    let width, height;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - slider.offsetHeight;
      width = canvas.width;
      height = canvas.height;
    }

    resize();
    window.addEventListener('resize', resize);

    function heartPosition(t) {
      return [
        Math.pow(Math.sin(t), 3),
        -(15 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)),
      ];
    }

    function scaleAndTranslate(pos, sx, sy, dx, dy) {
      return [dx + pos[0] * sx, dy + pos[1] * sy];
    }

    let pointsOrigin = [];
    let dr = 0.1;

    function initPoints() {
      pointsOrigin = [];
      for (let i = 0; i < Math.PI * 2; i += dr)
        pointsOrigin.push(scaleAndTranslate(heartPosition(i), 180, 10, 0, 0));
      for (let i = 0; i < Math.PI * 2; i += dr)
        pointsOrigin.push(scaleAndTranslate(heartPosition(i), 130, 7, 0, 0));
      for (let i = 0; i < Math.PI * 2; i += dr)
        pointsOrigin.push(scaleAndTranslate(heartPosition(i), 90, 4, 0, 0));
    }

    initPoints();
    let heartPointsCount = pointsOrigin.length;
    let targetPoints = [];

    function pulse(kx, ky) {
      for (let i = 0; i < pointsOrigin.length; i++) {
        targetPoints[i] = [
          kx * pointsOrigin[i][0] + width / 2,
          ky * pointsOrigin[i][1] + height / 2.2,
        ];
      }
    }

    let rand = Math.random;
    let e = [];

    // R…ông parametrl…ôri
    let targetHue = 270; // ba≈ülanƒüƒ±c r…ông tonu (b…ôn√∂v≈ü…ôyi)
    let currentHue = targetHue;

    function hslColor(h) {
      h = ((h % 360) + 360) % 360;
      return `hsl(${h}, 100%, 50%)`;
    }

    let currentColor = hslColor(currentHue);

    function initParticles() {
      e = [];
      for (let i = 0; i < heartPointsCount; i++) {
        let x = rand() * width;
        let y = rand() * height;
        e[i] = {
          vx: 0,
          vy: 0,
          R: 2,
          speed: rand() + 5,
          q: ~~(rand() * heartPointsCount),
          D: 2 * (i % 2) - 1,
          force: 0.2 * rand() + 0.7,
          f: currentColor,
          trace: Array.from({ length: 50 }, () => ({ x, y })),
        };
      }
    }

    initParticles();

    slider.addEventListener("mousedown", (e) => {
      let rect = slider.getBoundingClientRect();
      let x = Math.min(Math.max(0, e.clientX - rect.left), rect.width);
      moveThumb(x);

      document.onmousemove = function(e2) {
        let x = Math.min(Math.max(0, e2.clientX - rect.left), rect.width);
        moveThumb(x);
      };
      document.onmouseup = () => document.onmousemove = null;
    });

    function moveThumb(x) {
      x = Math.min(Math.max(0, x), slider.offsetWidth);
      thumb.style.left = x + "px";
      targetHue = (x / slider.offsetWidth) * 360;
    }

    let config = { traceK: 0.4, timeDelta: 0.6 };
    let time = 0;

    function loop() {
      // Animasiyanƒ±n k√∂hn…ô ritmi v…ô r…ông yum≈üaq ke√ßidi
      currentHue += (targetHue - currentHue) * 0.1;
      currentColor = hslColor(currentHue);

      for (let i = 0; i < e.length; i++) {
        e[i].f = currentColor;
      }

      let n = -Math.cos(time);
      pulse((1 + n) * 0.5, (1 + n) * 0.5);
      time += (Math.sin(time) < 0 ? 9 : n > 0.8 ? 0.2 : 1) * config.timeDelta;

      ctx.fillStyle = "rgba(0,0,0,0.1)"; // ∆èvv…ôlki kimi yum≈üaq iz effekti
      ctx.fillRect(0, 0, width, height);

      for (let i = e.length; i--;) {
        let u = e[i];
        let q = targetPoints[u.q];
        let dx = u.trace[0].x - q[0];
        let dy = u.trace[0].y - q[1];
        let length = Math.sqrt(dx * dx + dy * dy);

        if (length < 10) {
          if (rand() > 0.95) {
            u.q = ~~(rand() * heartPointsCount);
          } else {
            if (rand() > 0.99) u.D *= -1;
            u.q = (u.q + u.D) % heartPointsCount;
            if (u.q < 0) u.q += heartPointsCount;
          }
        }

        u.vx += (-dx / length) * u.speed;
        u.vy += (-dy / length) * u.speed;
        u.trace[0].x += u.vx;
        u.trace[0].y += u.vy;
        u.vx *= u.force;
        u.vy *= u.force;

        for (let k = 0; k < u.trace.length - 1; k++) {
          let T = u.trace[k];
          let N = u.trace[k + 1];
          N.x -= config.traceK * (N.x - T.x);
          N.y -= config.traceK * (N.y - T.y);
        }

        ctx.fillStyle = u.f;
        u.trace.forEach((t) => ctx.fillRect(t.x, t.y, 1, 1));
      }

      window.requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
